// asd - HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g, x, y, z;
array[10] output;

procedure one( x1, x2, x3, x4, x5 );
{
call OutputNum(x);
call OutputNum(2);
call OutputNum(3);
if a == 0 then
  call OutputNewLine()
fi;
call OutputNewLine()
};

function foo( x1, x2, x3, x4, x5 );
var i, d;
array[5] input;
{
  let i <- 0;
  while i < 10 do
    let y <- y + 2;
    let z <- x + 2;
    let d <- y + z;
    let i <- i + 1
  od;
  return d
};


{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  let a <- 1;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  call one(a,b,c,d,e);
  // call foo;

  if a == 10 then
    if a == 9 then
      let g <- g + a;
      call OutputNum(9);
      call OutputNum(g)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// asd - testing if/else with modifier in only one branch!
main 
var a, b;
array[5] input;
{
  let a <- call InputNum();
  let input[1] <- 22;
  let input[2] <- a;
  call OutputNum(input[1]);
  call OutputNum(a);
  if input[1] == 0 then
    call OutputNum(input[2])
  else
    call OutputNum(1337)
  fi;
  call OutputNewLine()
}.

// sample from notes
main
var n,f,g;
{
  let n <- 10;
  let f <- 1;
  while n > 0 do
    call OutputNum(1);
    let f <- f * n;
    let n <- n - 1;
    call OutputNum(f);
    let f <- f + 100;
    let n <- n * f;
    call OutputNum(n)
  od;

  let n <- f;
  call OutputNum(f);
  call OutputNum(n)
}.

// test case #1 from notes
main
var i,j;
{
  let i <- 0;
  let j <- 0;
  while i < 100 do
    let j <- call InputNum();
    let j <- j + 100000;
    call OutputNum(j);
    let i <- i + 1
  od;
  call OutputNum(i)
}.

// asd - nested while test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- a * 1000000;
    if a == 1 then
      let a <- a + 1;
      call OutputNum(1)
    else
      call OutputNum(0)
    fi;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.


// asd - HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g, x, y, z;

procedure one;
{
call OutputNum(1);
call OutputNum(2);
call OutputNum(3);
if a == 0 then
  call OutputNewLine()
fi;
call OutputNewLine()
};

function foo;
var i, d;
{
  let i <- 0;
  while i < 10 do
    let y <- y + 2;
    let z <- x + 2;
    let d <- y + z;
    let i <- i + 1
  od;
  return d
};


{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  let a <- 1;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  // call one;
  // call foo;

  if a == 10 then
    if a == 9 then
      let g <- g + a;
      call OutputNum(9);
      call OutputNum(g)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// sample from notes
main
var n,f,g;
{
  let n <- 10;
  let f <- 1;
  while n > 0 do
    call OutputNum(1);
    let f <- f * n;
    let n <- n - 1;
    call OutputNum(f);
    let f <- f + 100;
    let n <- n * f;
    call OutputNum(n)
  od;

  let n <- f;
  call OutputNum(f);
  call OutputNum(n)
}.

// asd - DOMINATOR TEST
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- a * 1000000;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.

// asd - DOMINATOR TEST
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.


// asd - HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;
  call OutputNum(a);
  call OutputNum(g)
}.

///  CSE TEST
main
var a, b, c, g, d, e, z, y, t, u;
{
let b <- call InputNum();
let c <- call InputNum();
let g <- call InputNum();
let d <- call InputNum();
if b < 1 then
  let a <- (b * c) + g;
  while b < 1 do
    let a <- (b * c) + d;
    call OutputNewLine()
  od
else
  let a <- (b * c) + g
fi;
let y <- (b * c) * d;
let u <- (b * c) * a;
let t <- (b * a) * d;
call OutputNum(y);
call OutputNum(u);
call OutputNum(t)
}.

// Nested dominator/cfg stuff - trying to get the graphs correct :-\ ...
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- b + 1;
  let d <- 10;
  let e <- call InputNum();
  if a == b then
    call OutputNum(1337);
    if a == c then
      while a == d do
        let d <- d / 2;
        call OutputNum(a)
      od
    else
      call OutputNum(c)
    fi
  else
    if a == c then
      let a <- a + 1;
      call OutputNum(100)
    else
      let f <- f + 1;
      call OutputNum(0);
      call OutputNum(b)
    fi
  fi;
  call OutputNum(a);
  let f <- e + 1;
  call OutputNewLine();
  call OutputNum(f)
}.

// Nested dominator/cfg stuff - trying to get the graphs correct :-\ ...
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- b + 1;
  while a < 10 do
    let a <- a - 1;
    if b == 0 then
      call OutputNum(1)
    else
      call OutputNum(2)
    fi
  od;
  call OutputNum(100);
  call OutputNewLine();
  if b == c then
    call OutputNum(a)
  else
    if a == 1 then
      call OutputNum(2)
    else
      call OutputNum(3)
    fi
  fi;
  call OutputNewLine()
}.


















// DU chain test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a + 1;
  let c <- b + 1;
  let d <- a + 1;
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c)
}.

// nested while/if statements
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    if a == 1 then
        let a <- 0;
        call OutputNum(100)
    else
        call OutputNum(b);
        while g == 0 do
            let g <- g - 1;
            call OutputNum(g)
        od;
        call OutputNum(g)
    fi;
    call OutputNum(a)
  od;
  call OutputNum(a);
  call OutputNum(g)
}.

// asd - Test case for graphs
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  if a == 0 then
    let a <- a - 1;
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// asd - HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  if a == 10 then
    if a == 9 then
      let g <- g + 1;
      call OutputNum(9)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// asd - modified in-class exercise with an obvious CSE and nested IF statements
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  if a == 10 then
    if a == 9 then
      let g <- g + 1;
      call OutputNum(9)
    else 
      call OutputNum(10)
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// asd - fixed!
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- a + 2;
  let c <- a + 2;
  call OutputNum(a);
  if a == 0 then
    let a <- 100;
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(1);
  call OutputNum(2)
}.

// asd - the if statement parsing for the phi is incorrect - it puts the everything at the wrong spot
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- a + 2;
  let c <- a + 2;
  call OutputNum(a);
  if a == 0 then
    let a <- 100;
    call OutputNum(0);
    call OutputNum(1)
  else
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(1);
  call OutputNum(2)
}.

// Partial parsing test to incrementally test all compiler features
main
var a, b, c, d, e, f, x, y, z; array[4] arr1;

// stupid function to return a constant
function one;
{
return 1
};

// sample foo function from test002.txt
// it takes parameters, much like everything else in this world does
//function foo( );
//var i, d;
//{
//let i <- 0;
//while i < 10 do
//let y <- y + 2;
//let z <- x + 2;
//let d <- y + z;
//let i <- i + 1
//od;
//return d
//};

// stupid function that takes some parameters and does some stuff with them
//function two;
 
{
    let a <- 51;
    let b <- a + 1 + 2 + 3 + 4 + 5;
    let c <- 1 * 8 + (6 * 4); 
    let d <- call InputNum();
    let e <- call InputNum();
    let f <- call one;
    call OutputNum(f);
    call OutputNum(a);
    call OutputNum(b);
    call OutputNum(c);
    call OutputNum(d);
    call OutputNewLine();
    
    let a <- d * e + 1;
    call OutputNum(a);
    
if d == 1 then
   call OutputNum(0)
else
   call OutputNum(1)
fi;

let b <- 100;
if b == 0 then
   let b <- 1
else
   let b <- 0
fi;

call OutputNum(b);

let a <- 0;
while a < 100 do
   let a <- a + 1;
   call OutputNum(a);
   call OutputNewLine()
od
}.
