main
array[5] input;
var maxnumber;
function max(a1,a2,a3,a4,a5);
array[5] arg;
var size,temp,i;
{
                let arg[0] <- a1;
                let arg[1] <- a2;
                let arg[2] <- a3;
                let arg[3] <- a4;
                let arg[4] <- a5;
                
                let size <- 5;
                let i <- 1;
                let temp <- arg[0];

                call OutputNewLine();
                call OutputNewLine();
                call OutputNum(temp);
                call OutputNum(arg[1]);
                call OutputNum(i);
                call OutputNum(size);
                call OutputNewLine();

                while i < size
                do
                    call OutputNum(temp);
                    call OutputNewLine();
                        if arg[i] > temp
                        then
                                let temp <- arg[i]
                        fi;
                        let i <- i+1
                od;

                call OutputNewLine();
                call OutputNewLine();
                call OutputNum(temp);
                call OutputNewLine();
                call OutputNewLine();

                return temp
        
}
;
{
        let input[0] <- 22;
        let        input[1] <- 61;
        let        input[2] <- 17;
        let        input[3] <- 34;
        let        input[4] <- 11;

        call OutputNum(input[0]);
        call OutputNum(input[1]);
        call OutputNum(input[2]);
        call OutputNum(input[3]);
        call OutputNum(input[4]);
        call OutputNewLine();
        
        let        maxnumber <- call max(input[0],input[1],input[2],input[3], input[4]);
        call OutputNum(maxnumber);
        call OutputNewLine()
        
}
.

// testing if/else with modifier in only one branch!
main 
var a, b;
array[5] input;
{
  let a <- call InputNum();
  let input[1] <- 22;
  let input[2] <- a;
  call OutputNum(input[1]);
  call OutputNum(a);
  if input[2] == 0 then
    call OutputNum(input[1])
  else
    call OutputNum(1337)
  fi;
  call OutputNewLine()
}.

// multidimensional array test
main 
var a, b, i, j;
array[10][10] output;
{
  while 1 != 2 do
    call OutputNewLine();
    let a <- call InputNum();
    let b <- call InputNum();
    let i <- call InputNum();
    let j <- call InputNum();

    call OutputNum(a + b);
    call OutputNum(i);
    call OutputNum(j);
    let output[i][j] <- a + b;
    call OutputNum(output[i][j]);
    call OutputNewLine();
    
    let i <- 0;
    while i < 10 do
      let j <- 0;
      while j < 10 do
        call OutputNum(output[i][j]);
        let j <- j + 1
      od;
      call OutputNewLine();
      let i <- i + 1
    od
  od
}.





// multidimensional array test
main 
var a, b, c;
array[10] output;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0] <- a + b;
  call OutputNum(output[0]);
  let c <- output[0];
  call OutputNum(c);
  call OutputNewLine()
}.

// dynamic array test
main 
var index;
array[10] output;

function getIndex();
{
  return (call InputNum())
};

function getValue();
{
  return (call InputNum())
};

procedure populate();
var a, i;
{
  let a <- call InputNum();
  let i <- call InputNum();
  let output[i] <- a
};

{
  // fill in the array
  let output[call getIndex()] <- call getValue();
  call OutputNum(output[call getIndex()]);
  call OutputNewLine();
  call OutputNewLine();

  // Populate
  //call populate();

  let index <- 0;
  while index < 10 do
    call OutputNum(index);
    call OutputNum(output[index]);
    call OutputNewLine();
    let index <- index + 1
  od
}.

// enveloping phis inside while loops
main
var a, b, c, d;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  while (a + b) <= c do
    let b <- c + 1;
    let a <- a + b + c + 1;
    let d <- 0;
    while d < b do
      call OutputNum(a);
      call OutputNum(b);
      call OutputNum(c);
      call OutputNum(d);
      call OutputNewLine();
      let a <- a + 1;
      let d <- d + 1;
      call OutputNum(b);
      call OutputNum(d);
      call OutputNewLine()
    od
  od;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNewLine()
}.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.



// dynamic array test
main 
var index;
array[10] output;

function populate(n, v);
var i;
array[5] localArray;
{
  call OutputNum(n);
  call OutputNum(v);
  let i <- 0;
  while i < 5 do
    let localArray[i] <- i + v;
    call OutputNum(localArray[i]);
    call OutputNewLine();
    let i <- i + 1
  od;
  return 10
};

{
  call OutputNum(call populate(5, 10));
  call OutputNewLine()
}.


// CSE with register allocation!
main
var input, output, a, b;

function test();
var i, f;
{
  return 1
};

{
  let input <- call InputNum();
  let output <- 0;
  call OutputNum(output);
  let output <- call test();
  call OutputNum(output);
  call OutputNum(input);
  call OutputNewLine();

  let a <- input + 1;
  let b <- input + 1;
  call OutputNum(a);
  call OutputNum(b);
  call OutputNewLine()
}
.

main
var input;

function factIter(n);
var i, f;
{
  let i <- 1;
  let f <- 1;
  while i <= n do
    let f <- f * i;
    let i <- i + 1
  od;
  return f
};

function factRec(n);
var i;
{
  if n <= 1 then
    return 1
  fi;
  return call factRec(n - 1) * n
};

{
  let input <- call InputNum();
  call OutputNum(input);
  call OutputNewLine();

  call OutputNum(call factIter(input));

  call OutputNum(input);
  call OutputNewLine();

  call OutputNum(call factRec(input));

  call OutputNum(input);
  call OutputNewLine()
}
.

// multidimensional array test
main 
var a, b, c, d, e, f, g, x, y, z;
array[10][2] output;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0][0] <- a + b;
  call OutputNum(output[0][0]);
  let c <- output[0][0];
  call OutputNum(c);
  call OutputNewLine()
}.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.

main
var input;

function factIter(n);
var i, f;
{
  let i <- 1;
  let f <- 1;
  while i <= n do
    let f <- f * i;
    let i <- i + 1
  od;
  call OutputNum(input);
  call OutputNum(i);
  call OutputNum(f);
  return f
};

{
  let input <- call InputNum();
  call OutputNum(call factIter(input));

  //call OutputNewLine();
  //call OutputNum(call factRec(input));

  call OutputNewLine()
}
.

function factRec(n);
{
  if n <= 1 then
    return 1
  fi;
  return call factRec(n - 1) * n
};

main
var a, b, c;

procedure foo( x );
var i;
{
  call OutputNewLine();
  call OutputNum(1337);
  call OutputNum(c);
  call OutputNum(x);
  call OutputNum(1337);
  call OutputNewLine();
  let c <- call InputNum();
  let a <- call InputNum()
};

{
  call OutputNum(a);
  call OutputNewLine();
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- call InputNum();
  let a <- a * 5 + 1;
  if a < 100 then
    call OutputNum(b);
    call OutputNewLine()
  else
    call OutputNum(a);
    call OutputNewLine()
  fi;

  call OutputNum(b);
  call OutputNewLine();

  while b > 0 do
    call OutputNum(b);
    call OutputNewLine();
    let a <- 666;
    let b <- b - 1
  od;

  call OutputNum(b);
  call OutputNewLine();

  call OutputNum(c);
  call OutputNewLine();

  call foo(a);

  call OutputNum(c);
  call OutputNewLine();

  call OutputNum(a);
  call OutputNewLine();

  call OutputNum(b);
  call OutputNewLine()
}.

main
var a, b;
{
  call OutputNum(a);
  call OutputNewLine();
  let a <- call InputNum();
  let b <- call InputNum();
  let a <- a * 5 + 1;
  if a < 100 then
    //let a <- call InputNum();
    //let a <- a + 1;
    call OutputNum(b)
  else
    call OutputNum(a)
  fi;

  while b < 5 do
    let b <- 10
  od;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNewLine()
}.

main
var input;

function factIter(n);
var i, f;
{
  let i <- 1;
  let f <- 1;
  while i <= n do
    let f <- f * i;
    let i <- i + 1
  od;
  return f
};

function factRec(n);
{
  if n <= 1 then
    return 1
  fi;
  return call factRec(n - 1) * n
};

{
  let input <- call InputNum();
  call OutputNum(call factIter(input));
  call OutputNewLine();
  call OutputNum(call factRec(input));
  call OutputNewLine()
}
.

main

procedure foo();
var i,b;
{
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od
};
{
  call foo()
}.


// Copy propagation test
main
procedure foo();
var a, b, c, d, e, f, g, h;
{
  let c <- a + b;
  let d <- c;
  let e <- d * d;
  let f <- a + c;
  let g <- e;
  let a <- g + d;
  
  if a < c then
    let h <- g + 1
  else
    let f <- d - g;
    if f > a then
      let c <- 2
    fi
  fi;
  
  let b <- g * a;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(f);
  call OutputNum(g);
  call OutputNum(h)
};

{
  call foo
}
.

// kind of hard, a lot of procedures
main
var x, y;
procedure foo( );
var a, b;
{
  let a <- 1;
  let b <- 2;
  let x <- a;
  let y <- b
};
procedure bar( a );
var b, c;
{
  let b <- 1;
  let c <- 1;
  let y <- b
};
procedure baz( a, b );
var c, d;
{
  let c <- 1;
  let y <- c
};
function boo( a, b );
var i;
{
  let i <- 0;
  while i < y do
    let x <- x * x;
    return
  od;
  return x + 4
  
};
{
  call foo( );
  call bar( 1 );
  //let x <- 3 + 7 - 2;
  let y <- ( 895 * 2 * 2 ) / 2;
  call baz( x, y );
  let y <- y + call boo( 2, 4 )
}
.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.

// test013.txt
main

function foo();
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  if a < b then
    let a <- a + 1;
    let e <- e + 1;
    if b < c then
      let c <- c * 3;
      while a < c do
        let a <- a + 1
      od
    fi;
    call OutputNum(1);
    let g <- 9 
  else
    let b <- b - 1;
    let f <- f + 1;
    if b < c then
      let c <- c * 3;
      while b < c do
        let b <- b + 1;
        let c <- c - 1
      od;
      call OutputNum(10)
    else
      let c <- c * 4;
      let d <- d + 1
    fi;
    let h <- 425
  fi;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);
  call OutputNum(h)
};

{
  call foo
}
.

// nested while test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- a * 1000000;
    while a != 1 do
      let a <- a + 1;
      call OutputNum(1)
    od;
    if a == 1 then
      let a <- a + 1;
      call OutputNum(1)    
    else
      call OutputNum(0)
    fi;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.

// modified in-class exercise with an obvious CSE and nested IF statements
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  if a == 10 then
    if a == 9 then
      let g <- g + 1;
      call OutputNum(9)
    else 
      call OutputNum(10)
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// test013.txt
main

function foo();
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  if a < b then
    let a <- a + 1;
    let e <- e + 1;
    if b < c then
      let c <- c * 3;
      while a < c do
        let a <- a + 1
      od
    fi;
    call OutputNum(1);
    let g <- 9 
  else
    let b <- b - 1;
    let f <- f + 1;
    if b < c then
      let c <- c * 3;
      while b < c do
        let b <- b + 1;
        let c <- c - 1
      od;
      call OutputNum(10)
    else
      let c <- c * 4;
      let d <- d + 1
    fi;
    let h <- 425
  fi;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);
  call OutputNum(h)
};

{
  call foo
}
.

// Simple DLX generator test
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- a + b;
  call OutputNum(c)
}.

// Interference graph test from class notes
main 
var a, b, c, d, e;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;

  if a < 0 then
    let d <- d + e;
    let a <- d
  else
    let d <- e
  fi;

  call OutputNum(a)
}.

// Enclosing loop header test
main 
var a, b, c, d, e;
{
  let a <- call InputNum();
  let b <- a;
  
  while b < 0 do
    let c <- a + 1;
    while a < 0 do
      call OutputNewLine()
    od
  od;
  call OutputNum(0)
}.

// Array test with assignment and then reference
main 
var a, b, c, d, e;
array[5] input;

procedure one( x1, x2 );
var x3;
{
  let x3 <- x1 + x2;
  call OutputNum(x3);
  call OutputNum(b)
};

function add( x1, x2 );
{
  return x1 + x2
//  let x1 <- 0;
//  return 1
};

{
  let a <- call InputNum();
  let b <- call InputNum();

  let input[0] <- 0;
  let input[1] <- a + b;
  let c <- input[1] + 1;
  let d <- call add(a, b);
  call OutputNum(d);
  call one(input[0], input[1]);

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(input[0]);
  call OutputNum(input[1]);
  call OutputNum(c) // this breaks it
}.

// multidimensional array test
main 
var a, b, c, d, e, f, g, x, y, z;
array[10][2] output;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0][0] <- a + b;
  call OutputNum(output[0][0]);
  let c <- output[0][0];
  call OutputNum(c);
  call OutputNewLine()
}.

// function calls with arbitrary parameters
main 
var a, b, c, d, e, f, g, x, y, z;
array[10] output;

procedure one( x1, x2 );
var x3;
{
  let x3 <- x1 + x2;
  call OutputNum(x3);
  call OutputNum(b)
};

{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0] <- 10;
  
  call one(a,output[0]);
  call OutputNum(a);
  call OutputNum(output[0])
}.

// nested while test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- call InputNum();

  let d <- c + 1;

  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- c * 1000000;
    let b <- c * 1000000;
    if a == 1 then
      let a <- a + 1;
      call OutputNum(1)
    else
      if b == 1 then
        call OutputNum(0);
        call OutputNum(b)
      fi
    fi;
    call OutputNum(a);
    let g <- c + 1;
    call OutputNum(g)
  od;


  let e <- c + 1;
  let f <- 0;
  

  

  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);

  call OutputNewLine()
}.

// testing if/else with modifier in only one branch!
main 
var a, b;
array[5] input;
{
  let a <- call InputNum();
  let input[1] <- 22;
  let input[2] <- a;
  call OutputNum(input[1]);
  call OutputNum(a);
  if input[1] == 0 then
    call OutputNum(input[2])
  else
    call OutputNum(1337)
  fi;
  call OutputNewLine()
}.

// sample from notes
main
var n,f,g;
{
  let n <- 10;
  let f <- 1;
  while n > 0 do
    call OutputNum(1);
    let f <- f * n;
    let n <- n - 1;
    call OutputNum(f);
    let f <- f + 100;
    let n <- n * f;
    call OutputNum(n)
  od;

  let n <- f;
  call OutputNum(f);
  call OutputNum(n)
}.

// test case #1 from notes
main
var i,j;
{
  let i <- 0;
  let j <- 0;
  while i < 100 do
    let j <- call InputNum();
    let j <- j + 100000;
    call OutputNum(j);
    let i <- i + 1
  od;
  call OutputNum(i)
}.


// HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g, x, y, z;

procedure one;
{
call OutputNum(1);
call OutputNum(2);
call OutputNum(3);
if a == 0 then
  call OutputNewLine()
fi;
call OutputNewLine()
};

function foo;
var i, d;
{
  let i <- 0;
  while i < 10 do
    let y <- y + 2;
    let z <- x + 2;
    let d <- y + z;
    let i <- i + 1
  od;
  return d
};


{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  let a <- 1;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  // call one;
  // call foo;

  if a == 10 then
    if a == 9 then
      let g <- g + a;
      call OutputNum(9);
      call OutputNum(g)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// sample from notes
main
var n,f,g;
{
  let n <- 10;
  let f <- 1;
  while n > 0 do
    call OutputNum(1);
    let f <- f * n;
    let n <- n - 1;
    call OutputNum(f);
    let f <- f + 100;
    let n <- n * f;
    call OutputNum(n)
  od;

  let n <- f;
  call OutputNum(f);
  call OutputNum(n)
}.

// DOMINATOR TEST
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- a * 1000000;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.

// DOMINATOR TEST
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.


// HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;
  call OutputNum(a);
  call OutputNum(g)
}.

///  CSE TEST
main
var a, b, c, g, d, e, z, y, t, u;
{
let b <- call InputNum();
let c <- call InputNum();
let g <- call InputNum();
let d <- call InputNum();
if b < 1 then
  let a <- (b * c) + g;
  while b < 1 do
    let a <- (b * c) + d;
    call OutputNewLine()
  od
else
  let a <- (b * c) + g
fi;
let y <- (b * c) * d;
let u <- (b * c) * a;
let t <- (b * a) * d;
call OutputNum(y);
call OutputNum(u);
call OutputNum(t)
}.

// Nested dominator/cfg stuff - trying to get the graphs correct :-\ ...
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- b + 1;
  let d <- 10;
  let e <- call InputNum();
  if a == b then
    call OutputNum(1337);
    if a == c then
      while a == d do
        let d <- d / 2;
        call OutputNum(a)
      od
    else
      call OutputNum(c)
    fi
  else
    if a == c then
      let a <- a + 1;
      call OutputNum(100)
    else
      let f <- f + 1;
      call OutputNum(0);
      call OutputNum(b)
    fi
  fi;
  call OutputNum(a);
  let f <- e + 1;
  call OutputNewLine();
  call OutputNum(f)
}.

// Nested dominator/cfg stuff - trying to get the graphs correct :-\ ...
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- b + 1;
  while a < 10 do
    let a <- a - 1;
    if b == 0 then
      call OutputNum(1)
    else
      call OutputNum(2)
    fi
  od;
  call OutputNum(100);
  call OutputNewLine();
  if b == c then
    call OutputNum(a)
  else
    if a == 1 then
      call OutputNum(2)
    else
      call OutputNum(3)
    fi
  fi;
  call OutputNewLine()
}.


















// DU chain test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a + 1;
  let c <- b + 1;
  let d <- a + 1;
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c)
}.

// nested while/if statements
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    if a == 1 then
        let a <- 0;
        call OutputNum(100)
    else
        call OutputNum(b);
        while g == 0 do
            let g <- g - 1;
            call OutputNum(g)
        od;
        call OutputNum(g)
    fi;
    call OutputNum(a)
  od;
  call OutputNum(a);
  call OutputNum(g)
}.

// Test case for graphs
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  if a == 0 then
    let a <- a - 1;
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  if a == 10 then
    if a == 9 then
      let g <- g + 1;
      call OutputNum(9)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// fixed!
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- a + 2;
  let c <- a + 2;
  call OutputNum(a);
  if a == 0 then
    let a <- 100;
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(1);
  call OutputNum(2)
}.

// the if statement parsing for the phi is incorrect - it puts the everything at the wrong spot
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- a + 2;
  let c <- a + 2;
  call OutputNum(a);
  if a == 0 then
    let a <- 100;
    call OutputNum(0);
    call OutputNum(1)
  else
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(1);
  call OutputNum(2)
}.

// Partial parsing test to incrementally test all compiler features
main
var a, b, c, d, e, f, x, y, z; array[4] arr1;

// stupid function to return a constant
function one;
{
return 1
};

// sample foo function from test002.txt
// it takes parameters, much like everything else in this world does
//function foo( );
//var i, d;
//{
//let i <- 0;
//while i < 10 do
//let y <- y + 2;
//let z <- x + 2;
//let d <- y + z;
//let i <- i + 1
//od;
//return d
//};

// stupid function that takes some parameters and does some stuff with them
//function two;
 
{
    let a <- 51;
    let b <- a + 1 + 2 + 3 + 4 + 5;
    let c <- 1 * 8 + (6 * 4); 
    let d <- call InputNum();
    let e <- call InputNum();
    let f <- call one;
    call OutputNum(f);
    call OutputNum(a);
    call OutputNum(b);
    call OutputNum(c);
    call OutputNum(d);
    call OutputNewLine();
    
    let a <- d * e + 1;
    call OutputNum(a);
    
if d == 1 then
   call OutputNum(0)
else
   call OutputNum(1)
fi;

let b <- 100;
if b == 0 then
   let b <- 1
else
   let b <- 0
fi;

call OutputNum(b);

let a <- 0;
while a < 100 do
   let a <- a + 1;
   call OutputNum(a);
   call OutputNewLine()
od
}.
