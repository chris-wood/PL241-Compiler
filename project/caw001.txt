// test003
main
array[ 2 ][ 3 ][ 4 ] a;
var b;
var c;
function foo( );
{
  call OutputNum(55);
  let b <- 2;
  let c <- 3;
  return b + c
};
function bar( );
{
  call OutputNum(35);
  let b <- 3;
  let c <- 4;
  return b + c
};

{
  let a[ 0 ][ 2 ][ 3 ] <- 1;
  let a[ 0 ][ 2 ][ 2 ] <- 2;
  call OutputNum(call foo);
  call OutputNum(a[ 0 ][ 2 ][ 3 ]);
  call OutputNum(a[ 0 ][ 2 ][ 2 ]);
  call OutputNewLine();
  if a[ 0 ][ 2 ][ 3 ] > a[ 0 ][ 2 ][ 2 ] then
    let a[ 0 ][ 2 ][ 1 ] <- call foo
    //call OutputNum(a[ 0 ][ 2 ][ 1 ]);
    //call OutputNewLine()
  else
    //let a[ 0 ][ 2 ][ 1 ] <- call foo
    let a[ 0 ][ 2 ][ 1 ] <- call bar;
    call OutputNum(a[ 0 ][ 2 ][ 1 ]);
    call OutputNewLine()
  fi;

  let b <- a[ 0 ][ 2 ][ 1 ];
  call OutputNum(b)
}.

// test020
main
array [ 5 ][ 10 ][ 15 ][ 20 ] a;
var b, c, d;
function foo( );
{
  return 13
};
{
  let b <- 1;
  let c <- 19;
  let a[ 4 ][ 9 ][ 1 + call foo( ) ][ b * c ] <- 45;
  let d <- a[ 4 ][ 9 ][ call foo( ) + 1 ][ c * b ] + 2
}
.

// test015
main
    var foo, too;
    var af;
    function bar(x);
    var par, q;
    {
        let q <-9;
        let par <- 3;
        while 3 < par do
            if 2 < 3 then
                let q <- par+q
                //let par <- 4
            fi;
            while 4 >= q do
                let q <- par - q
            od;
            let par <- q-3
        od;
        let x <- par+q;
        let af <- 4;
    return x
    };
    function funcfoo(x);
    var par, q;
    {
        let q <-9;
        let par <- 3;
        while 3 < par do
            let q <- par+q;
            while 4 >= q do
                let q <- par - q
            od;
            let par <- q-3
        od;
        let x <- par+q;
    return x
    };
    {
        let foo <- 3+too;
        let af <- foo+6;

        call OutputNum(foo);
        call OutputNum(af);
        call OutputNewLine()

    }
.

// CSE test
main
var a, b, c, d, e, f, g;
{
  let a <- b + c;
  let d <- c + b;
  call OutputNum(a);
  call OutputNum(d);
  call OutputNewLine()
}
.

// test011
main
var a, b, c, d;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNewLine();
  
  if a< b then
    let a <- a + 1;
    while c < d do
      let c <- c + 2;
      let d <- d + 1
    od
  else
    let a <- a + 2;
    while c < d do
      let c <- c + 3;
      let d <- d + 2
    od
  fi;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNewLine();
  
  while b < d do
    call OutputNum(1337);
    if a > d then
      let b <- c
    else
      let c <- b
    fi
  od;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNewLine()
}.




// test025
main
var a, b, c, d, e, f, g;
{
  let a <- b + c;
  let d <- b + c;
  let e <- c + b + d;
  
  if a != d then
    let e <- c + b + d;
    let f <- a * d;
    let g <- d * a + 4;
    let b <- 5;
    let e <- c + b + d
  else
    let f <- a / d;
    let g <- d / a
  fi;
  
  let f <- a * d;
  let g <- d / a
}
.

// multidimensional array test
main 
var a, b, i, j;
array[10][10] output;
{
  while 1 != 2 do
    call OutputNewLine();
    let a <- call InputNum();
    let b <- call InputNum();
    let i <- call InputNum();
    let j <- call InputNum();

    call OutputNum(a + b);
    call OutputNum(i);
    call OutputNum(j);
    let output[i][j] <- a + b;
    call OutputNum(output[i][j]);
    call OutputNewLine();
    
    let i <- 0;
    while i < 10 do
      let j <- 0;
      while j < 10 do
        call OutputNum(output[i][j]);
        let j <- j + 1
      od;
      call OutputNewLine();
      let i <- i + 1
    od
  od
}.

// test002
main
var x, y, z;
array [ 4 ] a;
array [ 4 ][ 4 ] b;
var c;
function foo( );
var i, d;
{
  let i <- 0;
  while i < 10 do
    let y <- y + 2;
    let z <- x + 2;
    let d <- y + z;
    let i <- i + 1
  od;
  return d
};

procedure bar( x, z );
var i, j, e;
{
  let i <- 0;
  let j <- 0;
  while i < 4 do
    while j < 4 do
      let b[ i ][ j ] <- j;
      let j <- j + 1
    od;
    let a[ i ] <- i;
    let i <- i + 1
  od
};

{
  let x <- 0;
  let y <- 0;
  let z <- 0;
  
  call bar( x, z );
  let c <- call foo;
  
  call OutputNum(c)
}.

// factorial
main
var input;

function factIter(n);
var i, f;
{
  let i <- 1;
  let f <- 1;
  while i <= n do
    let f <- f * i;
    let i <- i + 1
  od;
  return f
};

function factRec(n);
var i;
{
  if n <= 1 then
    return 1
  fi;
  return call factRec(n - 1) * n
};

{
  let input <- call InputNum();
  call OutputNum(input);
  call OutputNewLine();

  call OutputNum(call factIter(input));

  call OutputNum(input);
  call OutputNewLine();

  call OutputNum(call factRec(input));

  call OutputNum(input);
  call OutputNewLine()
}
.

main
array[5] input;
var maxnumber;
function max(a1,a2,a3,a4,a5);
array[5] arg;
var size,temp,i;
{
                let arg[0] <- a1;
                let arg[1] <- a2;
                let arg[2] <- a3;
                let arg[3] <- a4;
                let arg[4] <- a5;
                
                let size <- 5;
                let i <- 1;
                let temp <- arg[0];

                //call OutputNewLine();

                while i < size
                do
                  call OutputNum(temp);
                  call OutputNewLine();
                        if arg[i] > temp
                        then
                                call OutputNum(0);
                                let temp <- arg[i]
                        fi;
                        let i <- i+1
                od;

                call OutputNewLine();
                call OutputNum(temp);
                return temp
        
}
;
{
//        let input[0] <- 22;
//        let        input[1] <- 61;
//        let        input[2] <- 17;
//        let        input[3] <- 34;
//        let        input[4] <- 11;

        let input[0] <- call InputNum();
        let        input[1] <- call InputNum();
        let        input[2] <- call InputNum();
        let        input[3] <- call InputNum();
        let        input[4] <- call InputNum();

        call OutputNum(input[0]);
        call OutputNum(input[1]);
        call OutputNum(input[2]);
        call OutputNum(input[3]);
        call OutputNum(input[4]);
        call OutputNewLine();
        
        let maxnumber <- call max(input[0],input[1],input[2],input[3], input[4]);
        call OutputNewLine();
        call OutputNum(maxnumber);
        call OutputNewLine()
        
}
.

// test027
main 
    array [3] foo;
    array [3] boo;
    var a,b,c;
    {
        let a <- 3;
        let c <- foo[2*a-6];
        while 2 < 3 do
            let b <- foo[2*a-6];
            while 4 < foo[2*a-6] do            
                if 3 < 4 then
                    let boo[c] <- 3
                else
                    let foo[2] <- 5
                fi
            od;
            let c <- foo[2*a-6]
        od;
        let a <- foo[2*a-6]
    }    
.

// test023
main
var a, b, c, d, e;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  
  if ( c ) < d then
    if ( a + 5 - b ) > ( b * 6 ) then
      let a <- a / c * d;
      let d <- d - 1
    else
      let d <- a + b
    fi
  fi;
  
  let e <- c - a + b;
  let a <- a + b;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNewLine()
}
.




// test022
main
var a, b, c;
{
  let a <- 1;
  let b <- 2;
  let c <- 5;
  while b < c do
    let a <- b + 1;
    call OutputNum(a);
    while ( b + 1 ) < c do
      while ( b + 2 ) < c do
        let b <- b + 1
      od
    od
  od;
  let b <- c + 1;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNewLine()
}
.

// Simple CSE test
// (I don't like the ones in Muchnick)
main
var a, b, c, d, e, f, g;
{
  let a <- b + c;
  let d <- b + c;
  let e <- c + b + d;
  
  if a != d then
    let e <- c + b + d;
    let f <- a * d;
    let g <- d * a + 4;
    let b <- 5;
    let e <- c + b + d
  else
    let f <- a / d;
    let g <- d / a
  fi;
  
  let f <- a * d;
  let g <- d / a
}
.





// test013
main

function foo();
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  if a < b then
    let a <- a + 1;
    let e <- e + 1;
    if b < c then
      let c <- c * 3;
      while a < c do
        let a <- a + 1
      od
    fi;
    let g <- 9 
  else
    let b <- b - 1;
    let f <- f + 1;
    if b < c then
      let c <- c * 3;
      while b < c do
        let b <- b + 1;
        let c <- c - 1
      od
    else
      let c <- c * 4;
      let d <- d + 1
    fi;
    let h <- 425
  fi;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);
  call OutputNum(h)
};

{
  call foo
}
.


// test012
// From Brandis and Mossenbock
// The third line in the then block, the two lines before the if and he 
// lines after the fi are not part of the original test case. 
main
var a, b, c;
{
  let a <- 3;
  let b <- 2;
  if a < b then
    let a <- 1;
    let b <- a + 1;
    let a <- a + 1
  else
    let a <- a + 1;
    let c <- 2
  fi;
  let a <- a + 1;
    call OutputNum(a)
}.

// test016
main
var x, y;
procedure foo( );
var a, b;
{
  let a <- 1;
  let b <- 2;
  let x <- a;
  let y <- b
};
procedure bar( a );
var b, c;
{
  let b <- 1;
  let c <- 1;
  let y <- b
};
procedure baz( a, b );
var c, d;
{
  let c <- 1
};
function boo( a, b );
var i;
{
  let i <- 0;
  call OutputNum(x);
  while i < y do
    let i <- i + 1;
    let x <- x * x
  od;
  call OutputNum(x);
  call OutputNewLine();
  return x + 4
  
};
{
  call foo( );
  let x <- 3 + 7 - 2;
  call bar( 1 );
  let x <- 3 + 7 - 2;
  let y <- ( 895 * 2 * 2 ) / 2;
  call baz( x, y );
  call OutputNum(x);
  let y <- y + call boo( 2, 4 );

  call OutputNum(x);
  call OutputNum(y);
  call OutputNewLine()
}
.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.

// test029
main
var q, foo, af, too;
{
  let q<-foo;
  if 2 < 3 then            
    while 4 > 6 do
      let af <- foo+6;
      let foo <- q+2;
      let q<-foo
    od;
    let too <- foo+5
  fi;
  let af<-too+foo+q;

  call OutputNum(q);
  call OutputNum(foo);
  call OutputNum(af);
  call OutputNum(too);
  call OutputNewLine()
}
.




main
var a, b, c;
{
  let a <- 1;
  let b <- 2;
  let c <- 4;
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNewLine();

  if b < c then
    while ( b + 1 ) < c do
      let a <- a + 1;
      call OutputNum(a);
      call OutputNum(b);
      call OutputNum(c);
      while ( b + 1 ) < c do
        let b <- b + 1
      od;
      call OutputNum(b);
      call OutputNewLine()
    od
  fi;
  let b <- c + 1;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNewLine()
}
.


// test028
main
var a,b,c,d,e;
{
    let e <- b;
    let c <- 1;
    call OutputNum(a);
    call OutputNewLine();
    
    if e < 3 then
        let b <- a+4;
        let d <- b;
        call OutputNum(a);
        call OutputNewLine()
    else
        let c <- a+4
    fi;
    call OutputNum(b+e);
    call OutputNewLine();
    let a <- b+e;
    let d <- c+d;

    call OutputNum(a);
    call OutputNum(b);
    call OutputNum(c);
    call OutputNum(d);
    call OutputNum(e);
    call OutputNewLine()
}.







main
var a, b, c, d;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  
  if a< b then
    let a <- a + 1;
    while c < d do
      let c <- c + 2;
      let d <- d + 1
    od
  else
    let a <- a + 2;
    while c < d do
      let c <- c + 3;
      let d <- d + 2
    od
  fi;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNewLine();
  
  while b < d do
    call OutputNum(10);
    call OutputNewLine();
    if a > d then
      let b <- c
    else
      let c <- b
    fi
  od;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNewLine()
}.

// multidimensional array test
main 
var a, b, i, j;
array[10][10] output;
{
  while 1 != 2 do
    call OutputNewLine();
    let a <- call InputNum();
    let b <- call InputNum();
    let i <- call InputNum();
    let j <- call InputNum();

    call OutputNum(a + b);
    call OutputNum(i);
    call OutputNum(j);
    let output[i][j] <- a + b;
    call OutputNum(output[i][j]);
    call OutputNewLine();
    
    let i <- 0;
    while i < 10 do
      let j <- 0;
      while j < 10 do
        call OutputNum(output[i][j]);
        let j <- j + 1
      od;
      call OutputNewLine();
      let i <- i + 1
    od
  od
}.










main

function foo();
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  if a < b then
    let a <- a + 1;
    let e <- e + 1;
    if b < c then
      let c <- c * 3;
      while a < c do
        let a <- a + 1
      od
    fi;
    call OutputNum(a);
    call OutputNewLine();
    call OutputNewLine();
    let g <- 9 
  else
    let b <- b - 1;
    let f <- f + 1;
    if b < c then
      let c <- c * 3;
      while b < c do
        let b <- b + 1;
        let c <- c - 1
      od
    else
      let c <- c * 4;
      let d <- d + 1
    fi;
    let h <- 425
  fi;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);
  call OutputNum(g);
  call OutputNum(h)
};

{
  call foo
}
.


// Array testing
main
array [ 5 ][ 10 ][ 15 ][ 20 ] a;
var b, c, d;
function foo( );
{
  return 13
};
{
  let b <- 1;
  let c <- 19;
  let a[ 4 ][ 9 ][ 1 + call foo( ) ][ b * c ] <- 45;
  let d <- a[ 4 ][ 9 ][ call foo( ) + 1 ][ c * b ] + 2;
  call OutputNum(d)
}
.

// testing if/else with modifier in only one branch!
main 
var a, b;
array[5] input;
{
  let a <- call InputNum();
  let input[1] <- a;
  let input[2] <- input[1];
  call OutputNum(input[1]);
  call OutputNum(input[2]);
  call OutputNewLine()
}.


// Predefined function and procedure test
main
var a, b, c, d;
{
  let a <- call InputNum( );
  let b <- call InputNum( );
  let c <- call InputNum( );
  call OutputNum( a );
  call OutputNewLine( );
  
  while b > c do
    let d <- call InputNum( );
    
    let c <- c + 1;
    
    call OutputNum( d );
    call OutputNewLine( );
    
    let b <- b + 1
  od
}
.
 







// testing if/else with modifier in only one branch!
main 
var a, b;
array[5] input;
{
  let a <- call InputNum();
  let input[1] <- 22;
  let input[2] <- a;
  call OutputNum(input[1]);
  call OutputNum(a);
  if input[2] == 0 then
    call OutputNum(input[1])
  else
    call OutputNum(1337)
  fi;
  call OutputNewLine()
}.






// multidimensional array test
main 
var a, b, c;
array[10] output;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0] <- a + b;
  call OutputNum(output[0]);
  let c <- output[0];
  call OutputNum(c);
  call OutputNewLine()
}.

// dynamic array test
main 
var index;
array[10] output;

function getIndex();
{
  return (call InputNum())
};

function getValue();
{
  return (call InputNum())
};

procedure populate();
var a, i;
{
  let a <- call InputNum();
  let i <- call InputNum();
  let output[i] <- a
};

{
  // fill in the array
  let output[call getIndex()] <- call getValue();
  call OutputNum(output[call getIndex()]);
  call OutputNewLine();
  call OutputNewLine();

  // Populate
  //call populate();

  let index <- 0;
  while index < 10 do
    call OutputNum(index);
    call OutputNum(output[index]);
    call OutputNewLine();
    let index <- index + 1
  od
}.

// enveloping phis inside while loops
main
var a, b, c, d;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  while (a + b) <= c do
    let b <- c + 1;
    let a <- a + b + c + 1;
    let d <- 0;
    while d < b do
      call OutputNum(a);
      call OutputNum(b);
      call OutputNum(c);
      call OutputNum(d);
      call OutputNewLine();
      let a <- a + 1;
      let d <- d + 1;
      call OutputNum(b);
      call OutputNum(d);
      call OutputNewLine()
    od
  od;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNewLine()
}.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.



// dynamic array test
main 
var index;
array[10] output;

function populate(n, v);
var i;
array[5] localArray;
{
  call OutputNum(n);
  call OutputNum(v);
  let i <- 0;
  while i < 5 do
    let localArray[i] <- i + v;
    call OutputNum(localArray[i]);
    call OutputNewLine();
    let i <- i + 1
  od;
  return 10
};

{
  call OutputNum(call populate(5, 10));
  call OutputNewLine()
}.


// CSE with register allocation!
main
var input, output, a, b;

function test();
var i, f;
{
  return 1
};

{
  let input <- call InputNum();
  let output <- 0;
  call OutputNum(output);
  let output <- call test();
  call OutputNum(output);
  call OutputNum(input);
  call OutputNewLine();

  let a <- input + 1;
  let b <- input + 1;
  call OutputNum(a);
  call OutputNum(b);
  call OutputNewLine()
}
.



// multidimensional array test
main 
var a, b, c, d, e, f, g, x, y, z;
array[10][2] output;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0][0] <- a + b;
  call OutputNum(output[0][0]);
  let c <- output[0][0];
  call OutputNum(c);
  call OutputNewLine()
}.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.

main
var input;

function factIter(n);
var i, f;
{
  let i <- 1;
  let f <- 1;
  while i <= n do
    let f <- f * i;
    let i <- i + 1
  od;
  call OutputNum(input);
  call OutputNum(i);
  call OutputNum(f);
  return f
};

{
  let input <- call InputNum();
  call OutputNum(call factIter(input));

  //call OutputNewLine();
  //call OutputNum(call factRec(input));

  call OutputNewLine()
}
.

function factRec(n);
{
  if n <= 1 then
    return 1
  fi;
  return call factRec(n - 1) * n
};

main
var a, b, c;

procedure foo( x );
var i;
{
  call OutputNewLine();
  call OutputNum(1337);
  call OutputNum(c);
  call OutputNum(x);
  call OutputNum(1337);
  call OutputNewLine();
  let c <- call InputNum();
  let a <- call InputNum()
};

{
  call OutputNum(a);
  call OutputNewLine();
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- call InputNum();
  let a <- a * 5 + 1;
  if a < 100 then
    call OutputNum(b);
    call OutputNewLine()
  else
    call OutputNum(a);
    call OutputNewLine()
  fi;

  call OutputNum(b);
  call OutputNewLine();

  while b > 0 do
    call OutputNum(b);
    call OutputNewLine();
    let a <- 666;
    let b <- b - 1
  od;

  call OutputNum(b);
  call OutputNewLine();

  call OutputNum(c);
  call OutputNewLine();

  call foo(a);

  call OutputNum(c);
  call OutputNewLine();

  call OutputNum(a);
  call OutputNewLine();

  call OutputNum(b);
  call OutputNewLine()
}.

main
var a, b;
{
  call OutputNum(a);
  call OutputNewLine();
  let a <- call InputNum();
  let b <- call InputNum();
  let a <- a * 5 + 1;
  if a < 100 then
    //let a <- call InputNum();
    //let a <- a + 1;
    call OutputNum(b)
  else
    call OutputNum(a)
  fi;

  while b < 5 do
    let b <- 10
  od;

  call OutputNum(a);
  call OutputNum(b);
  call OutputNewLine()
}.

main
var input;

function factIter(n);
var i, f;
{
  let i <- 1;
  let f <- 1;
  while i <= n do
    let f <- f * i;
    let i <- i + 1
  od;
  return f
};

function factRec(n);
{
  if n <= 1 then
    return 1
  fi;
  return call factRec(n - 1) * n
};

{
  let input <- call InputNum();
  call OutputNum(call factIter(input));
  call OutputNewLine();
  call OutputNum(call factRec(input));
  call OutputNewLine()
}
.

main

procedure foo();
var i,b;
{
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od;
  let i <- 1;
  while i < 4 do
  let b <- call InputNum();
    call OutputNum(b);
    let i <- i + 1
  od
};
{
  call foo()
}.


// Copy propagation test
main
procedure foo();
var a, b, c, d, e, f, g, h;
{
  let c <- a + b;
  let d <- c;
  let e <- d * d;
  let f <- a + c;
  let g <- e;
  let a <- g + d;
  
  if a < c then
    let h <- g + 1
  else
    let f <- d - g;
    if f > a then
      let c <- 2
    fi
  fi;
  
  let b <- g * a;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(f);
  call OutputNum(g);
  call OutputNum(h)
};

{
  call foo
}
.

// kind of hard, a lot of procedures
main
var x, y;
procedure foo( );
var a, b;
{
  let a <- 1;
  let b <- 2;
  let x <- a;
  let y <- b
};
procedure bar( a );
var b, c;
{
  let b <- 1;
  let c <- 1;
  let y <- b
};
procedure baz( a, b );
var c, d;
{
  let c <- 1;
  let y <- c
};
function boo( a, b );
var i;
{
  let i <- 0;
  while i < y do
    let x <- x * x;
    return
  od;
  return x + 4
  
};
{
  call foo( );
  call bar( 1 );
  //let x <- 3 + 7 - 2;
  let y <- ( 895 * 2 * 2 ) / 2;
  call baz( x, y );
  let y <- y + call boo( 2, 4 )
}
.

// super hard
main
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  while (b / 4 + 5) < 8 do
    let a <- a * 7 + 9;
    if c < d then
      let g <- ( g - 5 ) * h;
      while g > h do
        let h <- h + 1
      od;
      let g <- g + h
    else
      if c >= d then
        let e <- f * f * 7 - 2;
        while (d - 7) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- f * e
      else
        let g <- 725;
        while (d - 8) != e do
          let d <- d - 1;
          let e <- e + 1
        od;
        let f <- (g * f) / 4
      fi;
      let g <- g + h
    fi

  od;
  let c <- a * d;
  let h <- g + h - 7;
  let e <- f + b * c
}
.

// test013.txt
main

function foo();
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  if a < b then
    let a <- a + 1;
    let e <- e + 1;
    if b < c then
      let c <- c * 3;
      while a < c do
        let a <- a + 1
      od
    fi;
    call OutputNum(1);
    let g <- 9 
  else
    let b <- b - 1;
    let f <- f + 1;
    if b < c then
      let c <- c * 3;
      while b < c do
        let b <- b + 1;
        let c <- c - 1
      od;
      call OutputNum(10)
    else
      let c <- c * 4;
      let d <- d + 1
    fi;
    let h <- 425
  fi;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);
  call OutputNum(h)
};

{
  call foo
}
.

// nested while test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- a * 1000000;
    while a != 1 do
      let a <- a + 1;
      call OutputNum(1)
    od;
    if a == 1 then
      let a <- a + 1;
      call OutputNum(1)    
    else
      call OutputNum(0)
    fi;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.

// modified in-class exercise with an obvious CSE and nested IF statements
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  if a == 10 then
    if a == 9 then
      let g <- g + 1;
      call OutputNum(9)
    else 
      call OutputNum(10)
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// test013.txt
main

function foo();
var a, b, c, d, e, f, g, h;
{
  let a <- 1;
  let b <- 2;
  let c <- 3;
  let d <- 4;
  let e <- 5;
  let f <- 6;
  let g <- 7;
  let h <- 8;
  
  if a < b then
    let a <- a + 1;
    let e <- e + 1;
    if b < c then
      let c <- c * 3;
      while a < c do
        let a <- a + 1
      od
    fi;
    call OutputNum(1);
    let g <- 9 
  else
    let b <- b - 1;
    let f <- f + 1;
    if b < c then
      let c <- c * 3;
      while b < c do
        let b <- b + 1;
        let c <- c - 1
      od;
      call OutputNum(10)
    else
      let c <- c * 4;
      let d <- d + 1
    fi;
    let h <- 425
  fi;
  
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c);
  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);
  call OutputNum(h)
};

{
  call foo
}
.

// Simple DLX generator test
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- a + b;
  call OutputNum(c)
}.

// Interference graph test from class notes
main 
var a, b, c, d, e;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;

  if a < 0 then
    let d <- d + e;
    let a <- d
  else
    let d <- e
  fi;

  call OutputNum(a)
}.

// Enclosing loop header test
main 
var a, b, c, d, e;
{
  let a <- call InputNum();
  let b <- a;
  
  while b < 0 do
    let c <- a + 1;
    while a < 0 do
      call OutputNewLine()
    od
  od;
  call OutputNum(0)
}.

// Array test with assignment and then reference
main 
var a, b, c, d, e;
array[5] input;

procedure one( x1, x2 );
var x3;
{
  let x3 <- x1 + x2;
  call OutputNum(x3);
  call OutputNum(b)
};

function add( x1, x2 );
{
  return x1 + x2
//  let x1 <- 0;
//  return 1
};

{
  let a <- call InputNum();
  let b <- call InputNum();

  let input[0] <- 0;
  let input[1] <- a + b;
  let c <- input[1] + 1;
  let d <- call add(a, b);
  call OutputNum(d);
  call one(input[0], input[1]);

  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(input[0]);
  call OutputNum(input[1]);
  call OutputNum(c) // this breaks it
}.

// multidimensional array test
main 
var a, b, c, d, e, f, g, x, y, z;
array[10][2] output;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0][0] <- a + b;
  call OutputNum(output[0][0]);
  let c <- output[0][0];
  call OutputNum(c);
  call OutputNewLine()
}.

// function calls with arbitrary parameters
main 
var a, b, c, d, e, f, g, x, y, z;
array[10] output;

procedure one( x1, x2 );
var x3;
{
  let x3 <- x1 + x2;
  call OutputNum(x3);
  call OutputNum(b)
};

{
  let a <- call InputNum();
  let b <- call InputNum();
  let output[0] <- 10;
  
  call one(a,output[0]);
  call OutputNum(a);
  call OutputNum(output[0])
}.

// nested while test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- call InputNum();

  let d <- c + 1;

  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- c * 1000000;
    let b <- c * 1000000;
    if a == 1 then
      let a <- a + 1;
      call OutputNum(1)
    else
      if b == 1 then
        call OutputNum(0);
        call OutputNum(b)
      fi
    fi;
    call OutputNum(a);
    let g <- c + 1;
    call OutputNum(g)
  od;


  let e <- c + 1;
  let f <- 0;
  

  

  call OutputNum(d);
  call OutputNum(e);
  call OutputNum(f);

  call OutputNewLine()
}.

// testing if/else with modifier in only one branch!
main 
var a, b;
array[5] input;
{
  let a <- call InputNum();
  let input[1] <- 22;
  let input[2] <- a;
  call OutputNum(input[1]);
  call OutputNum(a);
  if input[1] == 0 then
    call OutputNum(input[2])
  else
    call OutputNum(1337)
  fi;
  call OutputNewLine()
}.

// sample from notes
main
var n,f,g;
{
  let n <- 10;
  let f <- 1;
  while n > 0 do
    call OutputNum(1);
    let f <- f * n;
    let n <- n - 1;
    call OutputNum(f);
    let f <- f + 100;
    let n <- n * f;
    call OutputNum(n)
  od;

  let n <- f;
  call OutputNum(f);
  call OutputNum(n)
}.

// test case #1 from notes
main
var i,j;
{
  let i <- 0;
  let j <- 0;
  while i < 100 do
    let j <- call InputNum();
    let j <- j + 100000;
    call OutputNum(j);
    let i <- i + 1
  od;
  call OutputNum(i)
}.


// HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g, x, y, z;

procedure one;
{
call OutputNum(1);
call OutputNum(2);
call OutputNum(3);
if a == 0 then
  call OutputNewLine()
fi;
call OutputNewLine()
};

function foo;
var i, d;
{
  let i <- 0;
  while i < 10 do
    let y <- y + 2;
    let z <- x + 2;
    let d <- y + z;
    let i <- i + 1
  od;
  return d
};


{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  let a <- 1;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  // call one;
  // call foo;

  if a == 10 then
    if a == 9 then
      let g <- g + a;
      call OutputNum(9);
      call OutputNum(g)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// sample from notes
main
var n,f,g;
{
  let n <- 10;
  let f <- 1;
  while n > 0 do
    call OutputNum(1);
    let f <- f * n;
    let n <- n - 1;
    call OutputNum(f);
    let f <- f + 100;
    let n <- n * f;
    call OutputNum(n)
  od;

  let n <- f;
  call OutputNum(f);
  call OutputNum(n)
}.

// DOMINATOR TEST
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    let a <- a + 100;
    let a <- a * 1000000;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.

// DOMINATOR TEST
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  call OutputNewLine()
}.


// HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;
  call OutputNum(a);
  call OutputNum(g)
}.

///  CSE TEST
main
var a, b, c, g, d, e, z, y, t, u;
{
let b <- call InputNum();
let c <- call InputNum();
let g <- call InputNum();
let d <- call InputNum();
if b < 1 then
  let a <- (b * c) + g;
  while b < 1 do
    let a <- (b * c) + d;
    call OutputNewLine()
  od
else
  let a <- (b * c) + g
fi;
let y <- (b * c) * d;
let u <- (b * c) * a;
let t <- (b * a) * d;
call OutputNum(y);
call OutputNum(u);
call OutputNum(t)
}.

// Nested dominator/cfg stuff - trying to get the graphs correct :-\ ...
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- b + 1;
  let d <- 10;
  let e <- call InputNum();
  if a == b then
    call OutputNum(1337);
    if a == c then
      while a == d do
        let d <- d / 2;
        call OutputNum(a)
      od
    else
      call OutputNum(c)
    fi
  else
    if a == c then
      let a <- a + 1;
      call OutputNum(100)
    else
      let f <- f + 1;
      call OutputNum(0);
      call OutputNum(b)
    fi
  fi;
  call OutputNum(a);
  let f <- e + 1;
  call OutputNewLine();
  call OutputNum(f)
}.

// Nested dominator/cfg stuff - trying to get the graphs correct :-\ ...
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- call InputNum();
  let c <- b + 1;
  while a < 10 do
    let a <- a - 1;
    if b == 0 then
      call OutputNum(1)
    else
      call OutputNum(2)
    fi
  od;
  call OutputNum(100);
  call OutputNewLine();
  if b == c then
    call OutputNum(a)
  else
    if a == 1 then
      call OutputNum(2)
    else
      call OutputNum(3)
    fi
  fi;
  call OutputNewLine()
}.


















// DU chain test
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a + 1;
  let c <- b + 1;
  let d <- a + 1;
  call OutputNum(a);
  call OutputNum(b);
  call OutputNum(c)
}.

// nested while/if statements
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    if a == 1 then
        let a <- 0;
        call OutputNum(100)
    else
        call OutputNum(b);
        while g == 0 do
            let g <- g - 1;
            call OutputNum(g)
        od;
        call OutputNum(g)
    fi;
    call OutputNum(a)
  od;
  call OutputNum(a);
  call OutputNum(g)
}.

// Test case for graphs
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  if a == 0 then
    let a <- a - 1;
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// HARD FUCKING TEST CASE WITH NESTED THINGS AND PHIS
main 
var a, b, c, d, e, f, g;
{
  let a <- call InputNum();
  let b <- a;
  let c <- b;
  let d <- b + c;
  let e <- a + b;
  let f <- a + c;
  let g <- 10;
  while a > 0 do
    let a <- a - 1;
    call OutputNum(a)
  od;

  if a == 10 then
    if a == 9 then
      let g <- g + 1;
      call OutputNum(9)
    else 
      while a > 0 do
        let a <- a - 1;
        call OutputNum(a)
      od
    fi
  else
    call OutputNum(100)
  fi;
  call OutputNum(a);
  call OutputNum(g)
}.

// fixed!
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- a + 2;
  let c <- a + 2;
  call OutputNum(a);
  if a == 0 then
    let a <- 100;
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(1);
  call OutputNum(2)
}.

// the if statement parsing for the phi is incorrect - it puts the everything at the wrong spot
main 
var a, b, c;
{
  let a <- call InputNum();
  let b <- a + 2;
  let c <- a + 2;
  call OutputNum(a);
  if a == 0 then
    let a <- 100;
    call OutputNum(0);
    call OutputNum(1)
  else
    call OutputNum(a)
  fi;
  call OutputNum(a);
  call OutputNum(1);
  call OutputNum(2)
}.

// Partial parsing test to incrementally test all compiler features
main
var a, b, c, d, e, f, x, y, z; array[4] arr1;

// stupid function to return a constant
function one;
{
return 1
};

// sample foo function from test002.txt
// it takes parameters, much like everything else in this world does
//function foo( );
//var i, d;
//{
//let i <- 0;
//while i < 10 do
//let y <- y + 2;
//let z <- x + 2;
//let d <- y + z;
//let i <- i + 1
//od;
//return d
//};

// stupid function that takes some parameters and does some stuff with them
//function two;
 
{
    let a <- 51;
    let b <- a + 1 + 2 + 3 + 4 + 5;
    let c <- 1 * 8 + (6 * 4); 
    let d <- call InputNum();
    let e <- call InputNum();
    let f <- call one;
    call OutputNum(f);
    call OutputNum(a);
    call OutputNum(b);
    call OutputNum(c);
    call OutputNum(d);
    call OutputNewLine();
    
    let a <- d * e + 1;
    call OutputNum(a);
    
if d == 1 then
   call OutputNum(0)
else
   call OutputNum(1)
fi;

let b <- 100;
if b == 0 then
   let b <- 1
else
   let b <- 0
fi;

call OutputNum(b);

let a <- 0;
while a < 100 do
   let a <- a + 1;
   call OutputNum(a);
   call OutputNewLine()
od
}.
